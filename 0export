#!/usr/bin/env python
# Copyright (C) 2008, Thomas Leonard
# See the README file for details, or visit http://0install.net.

from optparse import OptionParser
import os, sys, tempfile, shutil, tarfile
from logging import warn, info, debug

ZEROINSTALL_URI = "http://0install.net/2007/interfaces/ZeroInstall.xml"

zeroinstall_dir = os.environ.get('0EXPORT_ZEROINSTALL', None)
if zeroinstall_dir:
	sys.path.insert(1, zeroinstall_dir)

version = '0.1'

extract_header = """#!/bin/sh
# 0export %s
archive_offset=00000
archive_format=application/x-tar
package_version=2
exec python - "$0" "$archive_offset" << EOF
""" + file(os.path.join(os.path.dirname(__file__), 'unpacker.py')).read() + """
EOF
exit 1
"""
extract_header = extract_header.replace('00000', "%05d" % len(extract_header))

parser = OptionParser(usage="usage: %prog setup.sh URI...\n"
			"Create setup.sh self-extracting installer for program(s) URI...")

parser.add_option("-j", "--injector", help="use custom zeroinstall-injector url", default=ZEROINSTALL_URI)
parser.add_option("-a", "--arch", help="add a target architecture (os-cpu)", metavar='CPU', action='append')
parser.add_option("-v", "--verbose", help="more verbose output", action='count')
parser.add_option("-V", "--version", help="display version information", action='store_true')

(options, args) = parser.parse_args()

if options.version:
	print "0export (zero-install) " + version
	print "Copyright (C) 2008 Thomas Leonard"
	print "This program comes with ABSOLUTELY NO WARRANTY,"
	print "to the extent permitted by law."
	print "You may redistribute copies of this program"
	print "under the terms of the GNU General Public License."
	print "For more information about these matters, see the file named COPYING."
	sys.exit(0)

if options.verbose:
	import logging
	logger = logging.getLogger()
	if options.verbose == 1:
		logger.setLevel(logging.INFO)
	else:
		logger.setLevel(logging.DEBUG)

if len(args) < 2:
	parser.print_help()
	sys.exit(1)

from zeroinstall import support
from zeroinstall.zerostore import BadDigest
from zeroinstall.injector import policy, handler, model, arch, solver
from zeroinstall import SafeException
import utils

setup_file = args[0]
uris = [model.canonical_iface_uri(x) for x in args[1:]]

if options.arch:
	def get_arch(arch_str):
		if '-' not in arch_str:
			raise Exception("Architecture syntax is OS-CPU (e.g. 'Linux-86_64')")
		os, cpu = arch_str.split('-', 1)
		if os in ("*", "any"): os = None
		if cpu in ("*", "any"): cpu = None
		return arch.get_architecture(os, cpu)
	archs = [get_arch(a) for a in options.arch]
else:
	archs = [arch.get_host_architecture()]

class ExportSolver(solver.SATSolver):
	def __init__(self, network_use, iface_cache, stores, extra_restrictions = None):
		solver.SATSolver.__init__(self, network_use, iface_cache, stores, extra_restrictions)

	def compare(self, interface, b, a, arch):
		# Prefer non-native packages all time to bundle them at first
		r = cmp(b.id.startswith('package:'), a.id.startswith('package:'))
		if r: return r
		return solver.SATSolver.compare(self, interface, b, a, arch)

solver.DefaultSolver = ExportSolver

def choose_implementations(uris):
	h = handler.Handler()

	feeds_used = set()		# URI
	implementations_used = {}	# ID -> Implementation
	uri_impls = {}			# Maps top-level URIs to implementations

	for uri in uris:
		print "Choosing versions for %s..." % uri
		versions = 0
		for target_arch in archs:
			p = policy.Policy(uri, h)
			p.target_arch = target_arch

			# Don't let us choose local devel versions
			p.solver.extra_restrictions = utils.NoLocalRestrictions()

			solved = p.solve_with_downloads()
			h.wait_for_blocker(solved)

			if not p.ready:
				if len(archs) > 1:
					warn("Failed to select any version for %s for architecture %s" % (uri, target_arch))
				continue
			versions += 1

			for iface, impl in p.solver.selections.items():
				if impl.id.startswith('package:'):
					debug('Skip package implementation %r', impl)
					continue
				print "  %-10s : %s (%s)" % (iface.get_name(), impl.get_version(), impl.arch)
				# TODO: assumes the ID is a digest (globally unique)
				# With 0launch >= 0.45, that might not be true.
				implementations_used[impl.id] = impl
			feeds_used = feeds_used | p.solver.feeds_used

			downloads = p.download_uncached_implementations()
			if downloads:
				print "Downloading implementations..."
				h.wait_for_blocker(downloads)

			iface_cache = p.solver.iface_cache

			uri_impls[uri] = p.solver.selections[iface_cache.get_interface(uri)].id

			for feed in p.solver.feeds_used:
				if feed.startswith('/'): continue
				iface = iface_cache.get_interface(feed)
				icon = iface_cache.get_icon_path(iface)
				if icon is None:
					download_icon = p.fetcher.download_icon(iface)
					if download_icon:
						print "Downloading icon..."
						h.wait_for_blocker(download_icon)
		if not versions:
			raise SafeException("Failed to select a set of versions for %s" % uri)

	return (feeds_used, implementations_used, uri_impls)

bootstrap_uris = [options.injector]

try:
	(bootstrap_feeds_used, bootstrap_implementations_used, bootstrap_uri_impls) = choose_implementations(bootstrap_uris)
	(feeds_used, implementations_used, uri_impls) = choose_implementations(uris)

	keys_used = set()

	print "Building package..."

	tmp = tempfile.mkdtemp(prefix = '0export-')
	bootstrap_tmp = tempfile.mkdtemp(prefix = '0export-')
	try:
		# Add feeds...
		utils.export_feeds(bootstrap_tmp, bootstrap_feeds_used | feeds_used, keys_used)

		# Add implementations...
		utils.export_impls(bootstrap_tmp, bootstrap_implementations_used)

		os.symlink(os.path.join('implementations', bootstrap_uri_impls[options.injector]), os.path.join(bootstrap_tmp, 'zeroinstall'))

		# Add keys...
		keys_dir = os.path.join(bootstrap_tmp, 'keys')
		os.mkdir(keys_dir)
		for key in keys_used:
			utils.export_key(key, keys_dir)

		# Add installer...
		mydir = os.path.dirname(os.path.abspath(sys.argv[0]))

		install_code = file(os.path.join(mydir, 'install.py')).read()
		install_code = install_code.replace('@ZEROINSTALL_URI@', options.injector)
		install_file = file(os.path.join(bootstrap_tmp, 'install.py'), 'w')
		install_file.write(install_code)
		install_file.close()

		# Record the toplevel interfaces (not those brought in only as dependencies)
		# These are the programs the installer will offer to run
		toplevels = file(os.path.join(bootstrap_tmp, 'toplevel_uris'), 'w')
		for uri in uris:
			toplevels.write(uri + '\n')
		toplevels.close()

		# Create an archive with bootstrap data
		bootstrap_path = os.path.join(tmp, 'bootstrap.tar.bz2')
		ts = tarfile.open(bootstrap_path, 'w|bz2')
		ts.add(bootstrap_tmp, '.')
		ts.close()

		# Collect all other implementations in separate archives in the archive
		impl_files = []
		for impl in set(implementations_used) - set(bootstrap_implementations_used):
			impltmp = tempfile.mkdtemp(prefix = '0export-')
			try:
				utils.export_impls(impltmp, {impl : implementations_used[impl]})
				implpath = os.path.join(tmp, impl + '.tar.bz2')
				ts = tarfile.open(implpath, 'w|bz2')
				ts.add(os.path.join(impltmp, 'implementations', impl), '.')
				ts.close()
			finally:
				support.ro_rmtree(impltmp)
			impl_files.append(implpath)

		setup_stream = file(setup_file, 'wb')
		setup_stream.write(extract_header)
		setup_tar = tarfile.open(setup_file, 'w|', setup_stream)
		setup_tar.add(bootstrap_path, os.path.basename(bootstrap_path))
		for impl in impl_files:
			setup_tar.add(impl, 'implementations/' + os.path.basename(impl))
		setup_tar.close()
		setup_stream.close()
		os.chmod(setup_file, (os.stat(setup_file).st_mode & 0777) | 0111)
	finally:
		support.ro_rmtree(bootstrap_tmp)
		support.ro_rmtree(tmp)
except BadDigest, ex:
	print >>sys.stderr, str(ex)
	if ex.detail:
		print >>sys.stderr, ex.detail
	sys.exit(1)
except SafeException, ex:
	print >>sys.stderr, str(ex)
	sys.exit(1)
